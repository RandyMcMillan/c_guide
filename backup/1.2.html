<html>
<head>
<title>
C Guide--1.2 Indentifiers
</title>
<!-- Changed by: eric huss, 12-Mar-1997 -->
</head>
<body text="#000000" bgcolor="#FFFFFF">
<center>
| <a href="index.html">Table of Contents</a> | <a href="index2.html">Index</a> |
</center>
<h1>1.2.1     Keywords</h1>
<p>
The following keywords are reserved and may not be used as an 
identifier for any other purpose.
<center>
<table>
<tr>
  <td><code><b>auto</b></code></td>
  <td><code><b>double</b></code></td>
  <td><code><b>int</b></code></td>
  <td><code><b>long</b></code></td>
</tr>
<tr>
  <td><code><b>break</b></code></td>
  <td><code><b>else</b></code></td>
  <td><code><b>long</b></code></td>
  <td><code><b>switch</b></code></td>
</tr>
<tr>
  <td><code><b>case</b></code></td>
  <td><code><b>enum</b></code></td>
  <td><code><b>register</b></code></td>
  <td><code><b>typedef</b></code></td>
</tr>
<tr>
  <td><code><b>char</b></code></td>
  <td><code><b>extern</b></code></td>
  <td><code><b>return</b></code></td>
  <td><code><b>union</b></code></td>
</tr>
<tr>
  <td><code><b>const</b></code></td>
  <td><code><b>float</b></code></td>
  <td><code><b>short</b></code></td>
  <td><code><b>unsigned</b></code></td>
</tr>
<tr>
  <td><code><b>continue</b></code></td>
  <td><code><b>for</b></code></td>
  <td><code><b>signed</b></code></td>
  <td><code><b>void</b></code></td>
</tr>
<tr>
  <td><code><b>default</b></code></td>
  <td><code><b>goto</b></code></td>
  <td><code><b>sizeof</b></code></td>
  <td><code><b>volatile</b></code></td>
</tr>
<tr>
  <td><code><b>do</b></code></td>
  <td><code><b>if</b></code></td>
  <td><code><b>static</b></code></td>
  <td><code><b>while</b></code></td>
</tr>
</table>
</center>

<h1>1.2.2     Variables</h1>
<p>
A variable may be defined using any uppercase or lowercase character,
a numerical digit
(0 through 9), and the underscore character (_).  The first character 
of the variable may not be a
numerical digit or underscore.  Variable names are case sensitive.
<p>
The scope of the variable (where it can be used), is determined 
by where it is defined.  If
it is defined outside any block or list of parameters, then it has 
<i>file scope</i>.  This means it may be
accessed anywhere in the current source code file.  This is normally 
called a global variable and
is normally defined at the top of the source code.  All other types 
of variables are local variables.
If a variable is defined in a block (encapsulated with <code><b>{</b></code> 
and <code><b>}</b></code>), then its scope begins when the
variable is defined and ends when it hits the terminating 
<code><b>}</b></code>.  This is called <i>block scope</i>.  If the
variable is defined in a function prototype, then the variable may 
only be accessed in that
function.  This is called <i>function prototype scope</i>.
<p>
Access to variables outside of their file scope can be made by using 
<i>linkage</i>.  Linkage is
done by placing the keyword <code><b>extern</b></code> prior to a variable 
declaration.  This allows a variable that is
defined in another source code file to be accessed.
<p>
Variables defined within a function scope have <i>automatic storage 
duration</i>.  The life of
the variable is determined by the life of the function.  Space is 
allocated at the beginning of the
function and terminated at the end of the function.  <i>Static storage 
duration</i> can be obtained by
placing the keyword <code><b>static</b></code> in front of the variable 
declaration.  This causes the variable's space
to be allocated when the program starts up and is kept during the life of 
the program.  The value
of the variable is preserved during subsequent calls to the function that 
defines it.  Variables
with file scope are automatically static variables.
<p>
A variable is defined by the following:
<blockquote>
     <blockquote>
          <i>storage-class-specifier  type-specifier variable-names,...</i><br>
     </blockquote>
     The storage-class-specifier can be one of the following:<br>
     <table>
     <tr>
       <td VALIGN=TOP><code><b>typedef</b></code></td>
       <td>The symbol name "<i>variable-name</i>" becomes a type-specifier
       of type "<i>type-specifier</i>".  No variable is actually created, 
       this is merely for convenience.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>extern</b></code></td>
       <td>Indicates that the variable is defined outside of the
       current file.  This brings the variables scope into the current 
       scope.  No variable is actually created by this.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>static</b></code></td>
       <td>Causes a variable that is defined within a function to be 
       preserved in subsequent calls to the function.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>auto</b></code></td>
       <td>Causes a local variable to have a local lifetime (default).</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>register</b></code></td>
       <td>Requests that the variable be accessed as quickly as
       possible.  This request is not guaranteed.  Normally, the variable's 
       value is kept within a CPU register for maximum speed.</td>
     </tr>
     </table>

     The type-specifier can be one of the following:<br>
     <table>
     <tr>
       <td VALIGN=TOP><code><b>void</b></code></td>
       <td VALIGN=TOP>Defines an empty or NULL value whose type is incomplete.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>char, signed char</b></code></td>
       <td VALIGN=TOP>Variable is large enough to store a basic character in the 
       character set.  The value is either signed or nonnegative.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>unsigned char</b></code></td>
       <td VALIGN=TOP>Same as char, but unsigned values only.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>short, signed short, short int, signed short int</b></code></td>
       <td VALIGN=TOP>Defines a short signed integer.  Normally the same range as a
       normal int, but may be half the bits of a normal int.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>unsigned short, unsigned short int</b></code></td>
       <td VALIGN=TOP>Defines an unsigned short integer.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>int, signed, signed int</b></code>, or no type specifier</td>
       <td VALIGN=TOP>Defines a signed integer.  If no type specifier is given,   
       then this is the default.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>unsigned int, unsigned</b></code></td>
       <td VALIGN=TOP>Same as int, but unsigned values only.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>long, signed long, long int, signed long int</b></code></td>
       <td VALIGN=TOP>Defines a long signed integer.  Normally twice the bit size  
       as a normal int, but may be the same as a normal int.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>unsigned long, unsigned long int</b></code></td>
       <td VALIGN=TOP>Same as long, but unsigned values only.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>float</b></code></td>
       <td VALIGN=TOP> A floating-point number.  Consists of a sign, a mantissa 
       (number greater than or equal to 1), and an exponent.  The 
       mantissa is taken to the power of the exponent then given the  
       sign.  The exponent is also signed allowing extremely small 
       fractions.  The mantissa gives it a finite precision.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>double</b></code></td>
       <td VALIGN=TOP>A more accurate floating-point number than float.  Normally 
       twice as many bits in size.</td>
     </tr>
     <tr>
       <td VALIGN=TOP><code><b>long double</b></code></td>
       <td VALIGN=TOP>Increases the size of double.</td>
     </tr>
     </table>
</blockquote>
<p>
Here are the maximum and minimum sizes of the type-specifiers on 
most common implementations.  Note: some implementations may be 
different.<br>
<center>
<table>
<tr>
  <td><b>Type</b></td>
  <td><b>Size</b></td>
  <td><b>Range</b></td>
</tr>
<tr>
  <td><code><b>unsigned char</b></code></td>
  <td>8 bits</td>
  <td>0 to 255</td>
</tr>
<tr>
  <td><code><b>char</b></code></td>
  <td>8 bits</td>
  <td>-128 to 127</td>
</tr>
<tr>
  <td><code><b>unsigned int</b></code></td>
  <td>16 bits</td>
  <td>0 to 65,535</td>
</tr>
<tr>
  <td><code><b>short int</b></code></td>
  <td>16 bits</td>
  <td>-32,768 to 32,767</td>
</tr>
<tr>
  <td><code><b>int</b></code></td>
  <td>16 bits</td>
  <td>-32,768 to 32,767</td>
</tr>
<tr>
  <td><code><b>unsigned long</b></code></td>
  <td>32 bits</td>
  <td>0 to 4,294,967,295</td>
</tr>
<tr>
  <td><code><b>long</b></code></td>
  <td>32 bits</td>
  <td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
  <td><code><b>float</b></code></td>
  <td>32 bits</td>
  <td>1.17549435 * (10^-38) to 3.40282347 * (10^+38)</td>
</tr>
<tr>
  <td><code><b>double</b></code></td>
  <td>64 bits</td>
  <td>2.2250738585072014 * (10^-308) to 1.7976931348623157 * (10^+308)</td>
</tr>
<tr>
  <td><code><b>long double</b></code></td>
  <td>80 bits</td>
  <td>3.4 * (10^-4932) to 1.1 * (10^4932)</td>
</tr>
</table> 
</center> 
Examples:<br>
<blockquote>
     <code><b>int bob=32;</b></code><br>
     Creates variable "bob" and initializes it to the value 32.<br>
<br>
     <code><b>char loop1,loop2,loop3='\x41';</b></code><br>
     Creates three variables.  The value of "loop1" and "loop2" 
     is undefined.  The value of loop3 is the letter "A".<br>
<br>
     <code><b>typedef char boolean;</b></code><br>
     Causes the keyword "boolean" to represent variable-type "char".<br>
<br>
     <code><b>boolean yes=1;</b></code><br>
     Creates variable "yes" as type "char" and sets its value to 1.
</blockquote>

<h1>1.2.3     Enumerated Tags</h1>
<p>
Enumeration allows a series of constant integers to be easily 
assigned.  The format to create a enumeration specifier is:
<blockquote>
     <code><b>enum </b></code><i>identifier</i><code><b> 
{</code></b><i>enumerator-list</i><code><b>};</b></code><br>
     <i>Identifier</i> is a handle for identification, and is optional.<br>
     <i>Enumerator-list</i> is a list of variables to be created.  They 
will be constant integers.  Each variable is given the value of the 
previous variable plus 1.  The first variable is given the value of 0.
</blockquote>
Examples: 
<blockquote>
     <code><b>enum {joe, mary, bob, fran};</b></code><br>
     Creates 4 variables.  The value of joe is 0, mary is 1,
     bob is 2, and fran is 3.<br>
<br>
     <ocde><b>enum test {larry, floyd=20, ted};</b></code><br>
     Creates 3 variables with the identifier test.  The value of larry is 
     0, floyd is 20, and ted is 21.
</blockquote>
<h1>1.2.4     Arrays</h1>
<p>
Arrays create single or multidimensional matrices.  They are defined 
by appending an integer encapsulated in brackets at the end of a variable 
name.  Each additional set of brackets defines an additional dimension to 
the array.  When addressing an index in the array, indexing
begins at 0 and ends at 1 less than the defined array.  If no initial 
value is given to the array size, then the size is determined by the 
initializers.  When defining a multidimensional array, nested
curly braces can be used to specify which dimension of the array to 
initialize.  The outermost nest of curly braces defines the leftmost 
dimension, and works from left to right.
<p>
Examples:
<blockquote>
     <code><b>int x[5];</b></code><br>
     Defines 5 integers starting at x[0], and ending at x[4].  
     Their values are undefined.<br>
<br>
     <code><b>char str[16]="Blueberry";</b></code><br>
     Creates a string.  The value at str[8] is the character 
     "y".  The value at str[9] is the null character.  The values 
     from str[10] to str[15] are undefined.<br>
<br>
     <code><b>char s[]="abc";</b></code><br>
     Dimensions the array to 4 (just long enough to hold the 
     string plus a null character), and stores the string in the array.<br>
<br>
     <code><b>int y[3]={4};</b></code><br>
     Sets the value of y[0] to 4 and y[1] and y[2] to 0.<br>
<br>
<pre><code><b>int joe[4][5]={
     {1,2,3,4,5},
     {6,7,8,9,10},
     {11,12,13,14,15}
};</b></code></pre>
     The first row initializes joe[0], the second row joe[1] and so 
     forth.  joe[3] is initialized to 5 zeros.<br>
<br>
     The same effect is achieved by:<br>
     <code><b>int joe[4][5]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};</b></code>
</blockquote>
<h1>1.2.5 Structures and Unions</h1>
<p>
Structures and unions provide a way to group common variables 
together.  To define a structure use:
<blockquote>
     <pre><code><b>struct </b></code><i>structure-name</i><code><b> {</b></code>

          <i>variables,...</i>

<code><b>}</code></b> <i>structure-variables,...</i><code><b>;</b></code></pre>
<br>
</blockquote>
     <i>Structure-name</i> is optional and not needed if the structure 
     variables are defined.  Inside it can contain any number of 
     variables separated by semicolons.  At the end,  
     <i>structure-variables</i> defines the actual names of the 
     individual structures. Multiple structures can be defined by 
     separating the variable names with commas.  If no 
     <i>structure-variables</i> are given, no variables are created.  
     <i>Structure-variables</i> can be defined separately by specifying:<br>
<br>
<blockquote>
     <code><b>struct </b></code><i>structure-name new-structure-variable</i><code><b>;</b></code><br>
</blockquote>
     <i>new-structure-variable</i> will be created and has a separate 
     instance of all the variables in <i>structure-name</i>.<br>
<br>
     To access a variable in the structure, you must use a record 
     selector (<code><b>.</b></code>).<br>
<br>
Unions work in the same way as structures except that all variables 
are contained in the same location in memory.  Enough space is allocated 
for only the largest variable in the union. All other variables must 
share the same memory location.  Unions are defined using the union
keyword.
<p> 
Examples:
<blockquote>
     <pre><code><b>struct my-structure {
     int fred[5];
     char wilma, betty;
     float barny=1;
};</b></code></pre>
     This defines the structure my-structure, but nothing has yet been done.<br>
<br>
     <code><b>struct my-structure account1;</b></code><br>
     This creates account1 and it has all of the variables from 
     my-structure.  account1.barny contains the value "1".<br>
<br>
     <pre><code><b>union my-union {
     char character_num;
     int integer_num;
     long long_num;
     float float_num;
     double double_num;
} number;</b></code></pre>
     This defines the union number and allocates just enough space for 
the variable double_num.<br>
<br>
     <code><b>number.integer_num=1;</b></code><br>
     Sets the value of integer_num to "1".<br>
     <code><b>number.float_num=5;</b></code><br>
     Sets the value of float_num to "5".<br>
     <code><b>printf("%i",integer_num);</b></code><br>
     This is undefined since the location of integer_num was overwritten 
     in the previous line by float_num.
</blockquote>
<h1>1.2.6 Constants</h1>
<p>
Constants provide a way to define a variable which cannot be 
modified by any other part in the code.  Constants can be defined by 
placing the keyword <code><b>const</b></code> in front of any variable
declaration.  If the keyword <code><b>volatile</b></code> is placed after 
<code><b>const</b></code>, then this allows external routines to modify the 
variable (such 
as hardware devices).  This also forces the compiler to retrieve the
value of the variable each time it is referenced rather than possibly 
optimizing it in a register.
<p>
Constant numbers can be defined in the following way:
<blockquote>
     Hexadecimal constant:
<blockquote>
          <code><b>0x </b></code><i>hexadecimal digits...</i><br>
          Where <i>hexadecimal digits</i> is any digit or any letter 
<code><b>A</b></code> through <code><b>F</b></code> or <code><b>a</b></code> 
through <code><b>f</b></code>.
</blockquote>
     Decimal constant:
<blockquote>
          Any number where the first number is not zero.
</blockquote>
     Octal constant:
<blockquote>
          Any number where the first number must be zero.
</blockquote>
     Floating constant:
<blockquote>
          A fractional number, optionally followed by either 
<code><b>e</b></code> or <code><b>E</b></code> then the exponent.
</blockquote>
 
     The number may be suffixed by:<br>
     <code><b>U</b></code> or <code><b>u</b></code>:
<blockquote>
          Causes the number to be an unsigned long integer.
</blockquote>
     <code><b>L</b></code> or <code><b>l</b></code>:
<blockquote>
          If the number is a floating-point number, then it is a long 
double, otherwise it is an unsigned long integer.
</blockquote>
     <code><b>F</b></code> or <code><b>f</b></code>:
<blockquote>
          Causes the number to be a floating-point number.
</blockquote>
</blockquote>
Examples:
<blockquote>
     <code><b>const float PI=3.141;</b></code><br>
     Causes the variable PI to be created with value 3.141.  
     Any subsequent attempts to write to PI are not allowed.<br>
<br>
     <code><b>const int joe=0xFFFF;</b></code><br>
     Causes joe to be created with the value of 65535 decimal.<br>
<br>
     <code><b>const float penny=7.4e5;</b></code><br>
     Causes penny to be created with the value of 740000.000000.
</blockquote>


<h1>1.2.7     Strings</h1>
<p>
 Strings are simply an array of characters encapsulated in double 
quotes.  At the end of the string a null character is appended.
<p>
Examples:
<blockquote>
     <code><b>"\x65"</b></code> and <code><b>"A"</b></code> are the same 
string.<br>
<br>
     <code><b>char fred[25]="He said, \"Go away!\"";</b></code><br>
     The value at fred[9] is a double quote.  The value at fred[20] is 
the null character.
</blockquote>


<h1>1.2.8     sizeof Keyword</h1>
          
Declaration:
<blockquote>
     <code><b>size_t sizeof </b></code><i>expression</i>
</blockquote>
<i>or</i>
<blockquote>
     <code><b>size_t sizeof (</b></code><i>type</i><code><b>)</b></code>
</blockquote>
     The sizeof keyword returns the number of bytes of the given 
expression or type.<br>
     <code><b>size_t</b></code> is an unsigned integer result.
<p>
Example:
<blockquote> 
<code><b>printf("The number of bytes in an int is %d.\n",sizeof(int));</b></code>
</blockquote>
<hr>
<center>
| <a href="index.html">Table of Contents</a> | <a href="index2.html">Index</a> |
</center>
</body>
</html>
