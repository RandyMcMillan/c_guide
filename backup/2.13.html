<html>
<head>
<title>
C Guide--2.13 stdlib.h
</title>
<!-- Changed by: eric huss, 12-Mar-1997 -->
</head>
<body text="#000000" bgcolor="#FFFFFF">
<center>
| <a href="index.html">Table of Contents</a> | <a href="index2.html">Index</a> |
</center>
<h1>2.13 stdlib.h</h1>
<p>
     The stdlib header defines several general operation functions and macros.
<p>
Macros:
<blockquote><b><code>
     NULL<br>
     EXIT_FAILURE<br>
     EXIT_SUCCESS<br>
     RAND_MAX<br>
     MB_CUR_MAX<br>
</code></b></blockquote>
<p>
Variables:
<blockquote><b><code>
     typedef size_t<br>
     typedef wchar_t<br>
     struct div_t<br>
     struct ldiv_t<br>
</code></b></blockquote>
<p>
Functions:
<blockquote><b><code>
     abort();<br>
     abs();<br>
     atexit();<br>
     atof();<br>
     atoi();<br>
     atol();<br>
     bsearch();<br>
     calloc();<br>
     div();<br>
     exit();<br>
     free();<br>
     getenv();<br>
     labs();<br>
     ldiv();<br>
     malloc();<br>
     mblen();<br>
     mbstowcs();<br>
     mbtowc();<br>
     qsort();<br>
     rand();<br>
     realloc();<br>
     srand();<br>
     strtod();<br>
     strtol();<br>
     strtoul();<br>
     system();<br>
     wcstombs();<br>
     wctomb();<br>
</code></b></blockquote>
<h2>2.13.1    Variables and Definitions</h2>
<p>
     <code><b>size_t</b></code> is the unsigned integer result of the <code><b>sizeof</b></code> keyword.<br>
     <code><b>wchar_t</b></code> is an integer type of the size of a wide character constant.<br>
     <code><b>div_t</b></code> is the structure returned by the <code><b>div</b></code> function.<br>
     <code><b>ldiv_t</b></code> is the structure returned by the <code><b>ldiv</b></code> function.<br>
<p>
     <code><b>NULL</b></code> is the value of a null pointer constant.<br>
     <code><b>EXIT_FAILURE</b></code> and <code><b>EXIT_SUCCESS</b></code> are values for the exit function to return
termination status.<br>
     <code><b>RAND_MAX</b></code> is the maximum value returned by the rand function.<br>
     <code><b>MB_CUR_MAX</b></code> is the maximum number of bytes in a multibyte character set which
cannot be larger than <code><b>MB_LEN_MAX</b></code>.<br>
<p>
<h2> 2.13.2    String Functions</h2>
<h2>2.13.2.1  atof</h2>
<p>
Declaration:
<blockquote><code><b>
     double atof(const char *</b></code><i>str</i><code><b>);
</b></code></blockquote>

     The string pointed to by the argument <i>str</i> is converted to a floating-point number (type
<code><b>double</b></code>).  Any initial whitespace characters are skipped (space, tab, carriage return, new line,
vertical tab, or formfeed).  The number may consist of an optional sign, a string of digits with an
optional decimal character, and an optional <code><b>e</b></code> or <code><b>E</b></code> followed by a optionally signed exponent. 
Conversion stops when the first unrecognized character is reached.
<p>
     On success the converted number is returned.  If no conversion can be made, zero is
returned.  If the value is out of range of the type double, then <code><b>HUGE_VAL</b></code> is returned with the
appropriate sign and <code><b>ERANGE</b></code> is stored in the variable <code><b>errno</b></code>.  If the value is too small to be
returned in the type <code><b>double</b></code>, then zero is returned and <code><b>ERANGE</b></code> is stored in the variable <code><b>errno</b></code>.

<h2>2.13.2.2  atoi</h2>
<p>
Declaration:
<blockquote><code><b>
     int atoi(const char *</b></code><i>str</i><code><b>);
</b></code></blockquote>

     The string pointed to by the argument <i>str</i> is converted to an integer (type <code><b>int</b></code>).  Any initial
whitespace characters are skipped (space, tab, carriage return, new line, vertical tab, or
formfeed).  The number may consist of an optional sign and a string of digits.  Conversion stops
when the first unrecognized character is reached.
<p>
     On success the converted number is returned.  If the number cannot be converted, then <code><b>0</b></code>
is returned.

<h2>2.13.2.3  atol</h2>
<p>
Declaration:
<blockquote><code><b>
     long int atol(const char *</b></code><i>str</i><code><b>);
</b></code></blockquote>

     The string pointed to by the argument <i>str</i> is converted to a long integer (type <code><b>long int</b></code>). 
Any initial whitespace characters are skipped (space, tab, carriage return, new line, vertical tab,
or formfeed).  The number may consist of an optional sign and a string of digits.  Conversion
stops when the first unrecognized character is reached.
<p>
     On success the converted number is returned.  If the number cannot be converted, then <code><b>0</b></code>
is returned.

<h2>2.13.2.4  strtod</h2>
<p>

Declaration:
<blockquote><code><b>
     double strtod(const char *</b></code><i>str</i><code><b>, char **</b></code><i>endptr</i><code><b>);
</b></code></blockquote>

     The string pointed to by the argument <i>str</i> is converted to a floating-point number (type
<code><b>double</b></code>).  Any initial whitespace characters are skipped (space, tab, carriage return, new line,
vertical tab, or formfeed).  The number may consist of an optional sign, a string of digits with an
optional decimal character, and an optional <code><b>e</b></code> or <code><b>E</b></code> followed by a optionally signed exponent. 
Conversion stops when the first unrecognized character is reached.
<p>
     The argument <i>endptr</i> is a pointer to a pointer.  The address of the character that stopped
the scan is stored in the pointer that <i>endptr</i> points to. 
<p>
     On success the converted number is returned.  If no conversion can be made, zero is
returned.  If the value is out of range of the type double, then <code><b>HUGE_VAL</b></code> is returned with the
appropriate sign and <code><b>ERANGE</b></code> is stored in the variable <code><b>errno</b></code>.  If the value is too small to be
returned in the type <code><b>double</b></code>, then zero is returned and <code><b>ERANGE</b></code> is stored in the variable <code><b>errno</b></code>.

<h2>2.13.2.5  strtol</h2>
<p>

Declaration:
<blockquote><code><b>
     long int strtol(const char *</b></code><i>str</i><code><b>, char **</b></code><i>endptr</i><code><b>, int </b></code><i>base</i><code><b>);
</b></code></blockquote>


     The string pointed to by the argument <i>str</i> is converted to a long integer (type <code><b>long int</b></code>). 
Any initial whitespace characters are skipped (space, tab, carriage return, new line, vertical tab,
or formfeed).  The number may consist of an optional sign and a string of digits.  Conversion
stops when the first unrecognized character is reached.
<p>
     If the <i>base</i> (radix) argument is zero, then the conversion is dependent on the first two
characters.  If the first character is a digit from 1 to 9, then it is base 10.  If the first digit is a zero
and the second digit is a digit from 1 to 7, then it is base 8 (octal).  If the first digit is a zero and
the second character is an x or X, then it is base 16 (hexadecimal).
<p>
     If the <i>base</i> argument is from 2 to 36, then that base (radix) is used and any characters that
fall outside of that base definition are considered unconvertible.  For base 11 to 36, the
characters A to Z (or a to z) are used.  If the base is 16, then the characters 0x or 0X may precede
the number.
<p>
     The argument <i>endptr</i> is a pointer to a pointer.  The address of the character that stopped
the scan is stored in the pointer that <i>endptr</i> points to. 
<p>
     On success the converted number is returned.  If no conversion can be made, zero is
returned.  If the value is out of the range of the type <code><b>long int</b></code>, then <code><b>LONG_MAX</b></code> or <code><b>LONG_MIN</b></code>
is returned with the sign of the correct value and <code><b>ERANGE</b></code> is stored in the variable <code><b>errno</b></code>.

<h2>2.13.2.6  strtoul</h2>
<p>

Declaration:
<blockquote><code><b>
     unsigned long int strtoul(const char *</b></code><i>str</i><code><b>, char **</b></code><i>endptr</i><code><b>, int </b></code><i>base</i><code><b>);
</b></code></blockquote>

     The string pointed to by the argument <i>str</i> is converted to an unsigned long integer (type
<code><b>unsigned long int</b></code>).  Any initial whitespace characters are skipped (space, tab, carriage return,
new line, vertical tab, or formfeed).  The number may consist of an optional sign and a string of
digits.  Conversion stops when the first unrecognized character is reached.
<p>
     If the <i>base</i> (radix) argument is zero, then the conversion is dependent on the first two
characters.  If the first character is a digit from 1 to 9, then it is base 10.  If the first digit is a zero
and the second digit is a digit from 1 to 7, then it is base 8 (octal).  If the first digit is a zero and
the second character is an x or X, then it is base 16 (hexadecimal).
<p>
     If the <i>base</i> argument is from 2 to 36, then that base (radix) is used and any characters that
fall outside of that base definition are considered unconvertible.  For base 11 to 36, the
characters A to Z (or a to z) are used.  If the <i>base</i> is 16, then the characters 0x or 0X may precede
the number.
<p>
     The argument <i>endptr</i> is a pointer to a pointer.  The address of the character that stopped
the scan is stored in the pointer that <i>endptr</i> points to. 
<p>
     On success the converted number is returned.  If no conversion can be made, zero is
returned.  If the value is out of the range of the type <code><b>unsigned long int</b></code>, then <code><b>ULONG_MAX</b></code> is
returned and <code><b>ERANGE</b></code> is stored in the variable <code><b>errno</b></code>.
<h2> 2.13.3    Memory Functions</h2>
<h2>2.13.3.1  calloc</h2>
<p>

Declaration:
<blockquote><code><b>
     void *calloc(size_t </b></code><i>nitems</i><code><b>, size_t </b></code><i>size</i><code><b>);
</b></code></blockquote>

     Allocates the requested memory and returns a pointer to it.  The requested size is <i>nitems</i>
each <i>size</i> bytes long (total memory requested is nitems*size).  The space is initialized to all zero
bits.
<p>
     On success a pointer to the requested space is returned.  On failure a null pointer is
returned.

<h2>2.13.3.2  free</h2>
<p>

Declaration:
<blockquote><code><b>
     void free(void *</b></code><i>ptr</i><code><b>);
</b></code></blockquote>

     Deallocates the memory previously allocated by a call to <code><b>calloc</b></code>, <code><b>malloc</b></code>, or <code><b>realloc</b></code>.  The
argument <i>ptr</i> points to the space that was previously allocated.  If <i>ptr</i> points to a memory block
that was not allocated with <code><b>calloc</b></code>, <code><b>malloc</b></code>, or <code><b>realloc</b></code>, or is a space that has been deallocated,
then the result is undefined.
<p>
     No value is returned.

<h2>2.13.3.3  malloc</h2>
<p>

Declaration:
<blockquote><code><b>
     void *malloc(size_t </b></code><i>size</i><code><b>);
</b></code></blockquote>

     Allocates the requested memory and returns a pointer to it.  The requested size is <i>size</i>
bytes.  The value of the space is indeterminate.
<p>
     On success a pointer to the requested space is returned.  On failure a null pointer is
returned.

<h2>2.13.3.4  realloc</h2>
<p>

Declaration:
<blockquote><code><b>
     void *realloc(void *</b></code><i>ptr</i><code><b>, size_t </b></code><i>size</i><code><b>);
</b></code></blockquote>

     Attempts to resize the memory block pointed to by <i>ptr</i> that was previously allocated with
a call to <code><b>malloc</b></code> or <code><b>calloc</b></code>.  The contents pointed to by <i>ptr</i> are unchanged.  If the value of <i>size</i> is
greater than the previous size of the block, then the additional bytes have an undeterminate
value.  If the value of <i>size</i> is less than the previous size of the block, then the difference of bytes
at the end of the block are freed.  If ptr is null, then it behaves like <code><b>malloc</b></code>.  If <i>ptr</i> points to a
memory block that was not allocated with <code><b>calloc</b></code> or <code><b>malloc</b></code>, or is a space that has been
deallocated, then the result is undefined.  If the new space cannot be allocated, then the contents
pointed to by <i>ptr</i> are unchanged.  If size is zero, then the memory block is completely freed.
<p>
     On success a pointer to the memory block is returned (which may be in a different
location as before).  On failure or if size is zero, a null pointer is returned.
<h2> 2.13.4    Environment Functions</h2>
<h2>2.13.4.1  abort</h2>
<p>

Declaration:
<blockquote><code><b>
     void abort(void);
</b></code></blockquote>

     Causes an abnormal program termination.  Raises the <code><b>SIGABRT</b></code> signal and an
unsuccessful termination status is returned to the environment.  Whether or not open streams are
closed is implementation-defined.
<p>
     No return is possible.

<h2>2.13.4.2  atexit</h2>
<p>

Declaration:
<blockquote><code><b>
     int atexit(void (*</b></code><i>func</i><code><b>)(void));
</b></code></blockquote>

     Causes the specified function to be called when the program terminates normally.  At
least 32 functions can be registered to be called when the program terminates.  They are called
in a last-in, first-out basis (the last function registered is called first).
<p>
     On success zero is returned.  On failure a nonzero value is returned.

<h2>2.13.4.3  exit</h2>
<p>

Declaration:
<blockquote><code><b>
     void exit(int </b></code><i>status</i><code><b>);
</b></code></blockquote>

     Causes the program to terminate normally.  First the functions registered by atexit are
called, then all open streams are flushed and closed, and all temporary files opened with tmpfile
are removed.  The value of <i>status</i> is returned to the environment.  If <i>status</i> is <code><b>EXIT_SUCCESS</b></code>,
then this signifies a successful termination.  If <i>status</i> is <code><b>EXIT_FAILURE</b></code>, then this signifies an
unsuccessful termination.  All other values are implementation-defined.
<p>
     No return is possible.

<h2>2.13.4.4  getenv</h2>
<p>

Declaration:
<blockquote><code><b>
     char *getenv(const char *</b></code><i>name</i><code><b>);
</b></code></blockquote>

     Searches for the environment string pointed to by <i>name</i> and returns the associated value
to the string.  This returned value should not be written to.
<p>
     If the string is found, then a pointer to the string's associated value is returned.  If the
string is not found, then a null pointer is returned.

<h2>2.13.4.5  system</h2>
<p>

Declaration:
<blockquote><code><b>
     int system(const char *</b></code><i>string</i><code><b>);
</b></code></blockquote>

     The command specified by string is passed to the host environment to be executed by the
command processor.  A null pointer can be used to inquire whether or not the command
processor exists.
<p>
     If string is a null pointer and the command processor exists, then zero is returned.  All
other return values are implementation-defined.
<h2> 2.13.5    Searching and Sorting Functions</h2>
<h2>2.13.5.1  bsearch</h2>
<p>

Declaration:
<blockquote><code><b>
     void *bsearch(const void *</b></code><i>key</i><code><b>, const void *</b></code><i>base</i><code><b>, size_t </b></code><i>nitems</i><code><b>, size_t </b></code><i>size</i><code><b>, int
(*</b></code><i>compar</i><code><b>)(const void *, const void *));
</b></code></blockquote>

     Performs a binary search.  The beginning of the array is pointed to by <i>base</i>.  It searches
for an element equal to that pointed to by <i>key</i>.  The array is <i>nitems</i> long with each element in the
array <i>size</i> bytes long.
<p>
     The method of comparing is specified by the <i>compar</i> function.  This function takes two
arguments, the first is the key pointer and the second is the current element in the array being
compared.  This function must return less than zero if the compared value is less than the
specified key.  It must return zero if the compared value is equal to the specified key.  It must
return greater than zero if the compared value is greater than the specified key.
<p>
     The array must be arranged so that elements that compare less than key are first,
elements that equal key are next, and elements that are greater than key are last.
<p>
     If a match is found, a pointer to this match is returned.  Otherwise a null pointer is
returned.  If multiple matching keys are found, which key is returned is unspecified.

<h2>2.13.5.2  qsort</h2>
<p>

Declaration:
<blockquote><code><b>
     void qsort(void *</b></code><i>base</i><code><b>, size_t </b></code><i>nitems</i><code><b>, size_t </b></code><i>size</i><code><b>, int (*</b></code><i>compar</i><code><b>)(const void *, const
void*));
</b></code></blockquote>

     Sorts an array.  The beginning of the array is pointed to by <i>base</i>.  The array is <i>nitems</i> long
with each element in the array <i>size</i> bytes long.
<p>
     The elements are sorted in ascending order according to the <i>compar</i> function.  This
function takes two arguments.  These arguments are two elements being compared.  This
function must return less than zero if the first argument is less than the second.  It must return
zero if the first argument is equal to the second.  It must return greater than zero if the first
argument is greater than the second.
<p>
     If multiple elements are equal, the order they are sorted in the array is unspecified.
<p>
     No value is returned.

<blockquote><code><b><pre>
Example:

#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main(void)
{
  char string_array[10][50]={"John",
                             "Jane",
                             "Mary",
                             "Rogery",
                             "Dave",
                             "Paul",
                             "Beavis",
                             "Astro",
                             "George",
                             "Elroy"};

  /* Sort the list */
  qsort(string_array,10,50,strcmp);

  /* Search for the item "Elroy" and print it */
  printf("%s",bsearch("Elroy",string_array,10,50,strcmp));

  return 0;
}
</pre></b></code></blockquote>
<h2> 2.13.6    Math Functions</h2>
<h2>2.13.6.1  abs</h2>
<p>

Declaration:
<blockquote><code><b>
     int abs(int </b></code><i>x</i><code><b>);
</b></code></blockquote>

     Returns the absolute value of <i>x</i>.  Note that in two's compliment that the most maximum
number cannot be represented as a positive number.  The result in this case is undefined.
<p>
     The absolute value is returned.

<h2>2.13.6.2  div</h2>
<p>

Declaration:
<blockquote><code><b>
     div_t div(int </b></code><i>numer</i><code><b>, int </b></code><i>denom</i><code><b>);
</b></code></blockquote>

     Divides <i>numer</i> (numerator) by <i>denom</i> (denominator).  The result is stored in the structure
<code><b>div_t</b></code> which has two members:
<blockquote>
<code><b>     int qout;<br>
     int rem;</b></code>
</blockquote>
     Where <i>quot</i> is the quotient and <i>rem</i> is the remainder.  In the case of inexact division, <i>quot</i>
is rounded down to the nearest integer.  The value <i>numer</i> is equal to <code><b>quot * denom + rem</b></code>.
<p>
     The value of the division is returned in the structure.

<h2>2.13.6.3  labs</h2>
<p>

Declaration:
<blockquote><code><b>
     long int labs(long int </b></code><i>x</i><code><b>);
</b></code></blockquote>

     Returns the absolute value of <i>x</i>.  Not that in two's compliment that the most maximum
number cannot be represented as a positive number.  The result in this case is undefined.
<p>
     The absolute value is returned.

<h2>2.13.6.4  ldiv</h2>
<p>

Declaration:
<blockquote><code><b>
     ldiv_t ldiv(long int </b></code><i>numer</i><code><b>, long int </b></code><i>denom</i><code><b>);
</b></code></blockquote>

     Divides <i>numer</i> (numerator) by <i>denom</i> (denominator).  The result is stored in the structure
<code><b>ldiv_t</b></code> which has two members:
<blockquote>
<code><b>     long int qout;<br>
     long int rem;</b></code>
</blockquote>
     Where <i>quot</i> is the quotient and <i>rem</i> is the remainder.  In the case of inexact division, <i>quot</i>
is rounded down to the nearest integer.  The value <i>numer</i> is equal to <code><b>quot * denom + rem</b></code>.
<p>
     The value of the division is returned in the structure.

<h2>2.13.6.5  rand</h2>
<p>

Declaration:
<blockquote><code><b>
     int rand(void);
</b></code></blockquote>

     Returns a pseudo-random number in the range of <code><b>0</b></code> to <code><b>RAND_MAX</b></code>.
<p>
     The random number is returned.

<h2>2.13.6.6  srand</h2>

<p>

Declaration:
<blockquote><code><b>
     void srand(unsigned int </b></code><i>seed</i><code><b>);
</b></code></blockquote>

     This function seeds the random number generator used by the function <code><b>rand</b></code>.  Seeding
<code><b>srand</b></code> with the same seed will cause <code><b>rand</b></code> to return the same sequence of pseudo-random
numbers.  If <code><b>srand</b></code> is not called, <code><b>rand</b></code> acts as if <code><b>srand(1)</b></code> has been called.
<p>
     No value is returned.
<h2> 2.13.7    Multibyte Functions</h2>

     The behavior of the multibyte functions are affected by the setting of <code><b>LC_CTYPE</b></code> in the
location settings.

<h2>2.13.7.1  mblen</h2>
<p>

Declaration:
<blockquote><code><b>
     int mblen(const char *</b></code><i>str</i><code><b>, size_t </b></code><i>n</i><code><b>);
</b></code></blockquote>

     Returns the length of a multibyte character pointed to by the argument <i>str</i>.  At most <i>n</i>
bytes will be examined.
<p>
     If <i>str</i> is a null pointer, then zero is returned if multibyte characters are not
state-dependent (shift state).  Otherwise a nonzero value is returned if multibyte character are
state-dependent.
<p>
     If <i>str</i> is not null, then the number of bytes that are contained in the multibyte character
pointed to by <i>str</i> are returned.  Zero is returned if str points to a null character.  A value of -1 is
returned if <i>str</i> does not point to a valid multibyte character.

<h2>2.13.7.2  mbstowcs</h2>
<p>

Declaration:
<blockquote><code><b>
     size_t mbstowcs(schar_t *</b></code><i>pwcs</i><code><b>, const char *</b></code><i>str</i><code><b>, size_t </b></code><i>n</i><code><b>);
</b></code></blockquote>

     Converts the string of multibyte characters pointed to by the argument <i>str</i> to the array
pointed to by <i>pwcs</i>.  It stores no more than <i>n</i> values into the array.  Conversion stops when it
reaches the null character or <i>n</i> values have been stored.  The null character is stored in the array
as zero but is not counted in the return value.
<p>
     If an invalid multibyte character is reached, then the value -1 is returned.  Otherwise the
number of values stored in the array is returned not including the terminating zero character.

<h2>2.13.7.3  mbtowc</h2>
<p>

Declaration:
<blockquote><code><b>
     int mbtowc(whcar_t *</b></code><i>pwc</i><code><b>, const char *</b></code><i>str</i><code><b>, size_t </b></code><i>n</i><code><b>);
</b></code></blockquote>

     Examines the multibyte character pointed to by the argument <i>str</i>.  The value is converted
and stored in the argument <i>pwc</i> if <i>pwc</i> is not null.  It scans at most <i>n</i> bytes.
<p>
     If <i>str</i> is a null pointer, then zero is returned if multibyte characters are not
state-dependent (shift state).  Otherwise a nonzero value is returned if multibyte character are
state-dependent.
<p>
     If <i>str</i> is not null, then the number of bytes that are contained in the multibyte character
pointed to by str are returned.  Zero is returned if <i>str</i> points to a null character.  A value of -1 is
returned if <i>str</i> does not point to a valid multibyte character.

<h2>2.13.7.4  wcstombs</h2>
<p>

Declaration:
<blockquote><code><b>
     size_t wcstombs(char *</b></code><i>str</i><code><b>, const wchar_t *</b></code><i>pwcs</i><code><b>, size_t </b></code><i>n</i><code><b>);
</b></code></blockquote>

     Converts the codes stored in the array <i>pwcs</i> to multibyte characters and stores them in the
string <i>str</i>.  It copies at most <i>n</i> bytes to the string.  If a multibyte character overflows the <i>n</i>
constriction, then none of that multibyte character's bytes are copied.  Conversion stops when it
reaches the null character or <i>n</i> bytes have been written to the string.  The null character is stored
in the string, but is not counted in the return value.
<p>
     If an invalid code is reached, the value -1 is returned.  Otherwise the number of bytes
stored in the string is returned not including the terminating null character.

<h2>2.13.7.5  wctomb</h2>
<p>

Declaration:
<blockquote><code><b>
     int wctomb(char *</b></code><i>str</i><code><b>, wchar_t </b></code><i>wchar</i><code><b>);
</b></code></blockquote>

     Examines the code which corresponds to a multibyte character given by the argument
<i>wchar</i>.  The code is converted to a multibyte character and stored into the string pointed to by
the argument <i>str</i> if <i>str</i> is not null.
<p>
     If <i>str</i> is a null pointer, then zero is returned if multibyte characters are not
state-dependent (shift state).  Otherwise a nonzero value is returned if multibyte character are
state-dependent.
<p>
     If <i>str</i> is not null, then the number of bytes that are contained in the multibyte character
wchar are returned.  A value of -1 is returned if wchar is not a valid multibyte character.
<hr>
<center>
| <a href="index.html">Table of Contents</a> | <a href="index2.html">Index</a> |
</center>
</body>
</html>
